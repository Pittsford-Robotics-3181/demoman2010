package demoman;
import edu.wpi.first.wpilibj.*;

/*
*	Team 3181 Robotics
*		Project:	Breakaway
*		Codename:	Demoman
*						(The Chargin Scottsman)
*		Filename:	Kicking.java
*/
/**		
*	All the kicking functions are housed here.
*	
*	@author eric                                                 
*
*/

public class Kicking {

	// [if you're looking for those kicking variables, they've been replaced by threading]
	
	/**
	*	Kick the ball.  ONLY CALL THIS FUNCTION IF YOU ACTUALLY WANT TO KICK GODDAMMIT.
	*	
	
   / /_  _________  / /_____  ____     / /_  _________  / /_____  ____ 
  / __ \/ ___/ __ \/ //_/ _ \/ __ \   / __ \/ ___/ __ \/ //_/ _ \/ __ \
 / /_/ / /  / /_/ / ,< /  __/ / / /  / /_/ / /  / /_/ / ,< /  __/ / / /
/_.___/_/   \____/_/|_|\___/_/ /_/  /_.___/_/   \____/_/|_|\___/_/ /_/ 

	*
	*
	*/
	public static void kickBall() {
		/*
		 *	When not called:	- Fire S3 and S4 to keep the pressure up
		 *	When called:		- Fire S5, which releases the latch
		 *						- Start a timer
		 *	S1, S2 fire 1.5 seconds afterwards
		 *	S3, S4 turn off 
		 */

		// Shoot if we can
		if (Hardware.kickerLatchSwitch.get()) {
			Hardware.solenoids[4].set(true);
			// Retract the kicker
			try {
				(new HelloThread()).start();
			} catch (InterruptedException ex) {
				// This shouldn't ever happen
				system.out.println("Kicking thread has been interrupted");
			}
		} else {
            // Can't kick because the kicker isn't there!
		}
		
		// If the latch is closed, shut off S1 and S2, because they've done their job
		if (Hardware.kickerLatchSwitch.get()) {
			Hardware.solenoids[0].set(false);
			Hardware.solenoids[1].set(false);
			// Start 3&4 to repressurize the piston
			Hardware.solenoids[2].set(true);
			Hardware.solenoids[3].set(true);
		}
		
		/*
		// Check to see if this is the first loop the latch has been open for
			// The isStale switch is VERY important:
			// if the user holds down the trigger for more than one teleop loop (1/10000 of a second)
			// the timer will reset with each subsequent teleop loop unless we only let it reset itself
			// if the terminal time (~1.5 seconds) has been reached
		if (!Hardware.kickerLatchSwitch.get() && !kickerTimerIsStale) {
			kickerTimer.reset();
			kickerTimer.start();
			kickerTimerIsStale = true;
		}
		
		// If the latch is closed, shut off S1 and S2, because they've done their job
		if (Hardware.kickerLatchSwitch.get()) {
			Hardware.solenoids[0].set(false);
			Hardware.solenoids[1].set(false);
			// Stop and reset the timer.  
			kickerTimer.stop();
			kickerTimer.reset();
            kickerTimerIsStale = false;
			// Start 3&4 to repressurize
			Hardware.solenoids[2].set(true);
			Hardware.solenoids[3].set(true);
		}

		
		// Reset the latch solenoid BEFORE you retract the kicker
		if (kickerTimer.get() > .85) {
			Hardware.solenoids[4].set(false);
		}
		
		// Retract the kicker
		if (kickerTimer.get() >= 1.5) {
			Hardware.solenoids[0].set(true);
			Hardware.solenoids[1].set(true);
			Hardware.solenoids[2].set(false);
			Hardware.solenoids[3].set(false);
		} */
		
		// DIAGNOSTIC - use a solenoid because println eats all the ram
		Hardware.solenoids[7].set(Hardware.kickerLatchSwitch.get());
		
	}
	
	// INNER CLASSS
	private class RetractingThread extends Thread {
		public void run() {
			// Wait .85 seconds
			Thread.sleep(850);
			// Reset the latch solenoid
			Hardware.solenoids[4].set(false);
			
			// Wait .65 seconds
			Thread.sleep(650);
			// Retract the kicker
			Hardware.solenoids[0].set(true);
			Hardware.solenoids[1].set(true);
			Hardware.solenoids[2].set(false);
			Hardware.solenoids[3].set(false);
		}
	}
	// END INNER CLASS

}